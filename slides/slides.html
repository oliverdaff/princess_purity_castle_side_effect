<div class="slides" id="slides">
        <section data-transition="slide">
        <h1>Functors, Apply, Applicative and Monads</h1>
        </section>

        <section data-transition="slide">
          <h2>That's just dull</h2>
        </section>

        <section data-transition="slide">
          <h2>So let's try instead ...</h2>
        </section>

        <section data-transition="slide" data-background-size="contain" data-background="images/princesspurity.png" >
          <p>.</p>
        </section>

        <section data-transition="slide">
          <h1>Why should you care?</h1>
          <p>How do Functors, Apply, Applicative and Monad help you achieve early and continuous delivery of software?</p>
        </section>

        <section data-transition="slide">
          <h1>3 Concepts</h1>
        </section>

        <section data-transition="slide">
          <h2>If a pizza costs $16 and you buy two how much do you spend?</h2>
          <img data-src="images/mario_pizza.jpg" />
        </section>

        <section data-transition="slide">
          <h2>A mario kart costs $20 per day to rent. How much does it cost to rent for two days?</h2>
          <img data-src="images/monkey_cart.gif" />
        </section>

        <section data-transition="slide">
          <h2>Don't just think about the maths</h2>
          <p>Think about the process you are going through before you get to the maths.</p>
          <p>What information are you keeping and what information are you dropping?</p>
        </section>

        <section data-transition="slide" data-background-size="contain" data-background="images/kandinsky.comp-8.jpg" >
          <p>.</p>
        </section>

        <section data-transition="slide">
          <h1>Abstraction</h1>
          <p>Abstraction is an emphasis on the idea, qualities and properties rather than the particulars</p>
          <p>The importance of abstraction is derived from its ability to hide irrelevant details</p>
          <p class="fragment">It doesn't matter if its pizza, mario carts or anything else we take the cost and muliply it by some factor.</p>
        </section>

        <section data-transition="slide">
          <h2>What is the realation ship between a pologon:</h2>
          <ul>
            <li>A 3 sided triangle</li>
            <li>A 4 sided quadrilateral</li>
          </ul>
        </section>

        <section data-transition="slide">
          <h2>What has a<sup>m</sup> × a<sup>n</sup> = a<sup>m+n</sup> got in common with:</h2>
          <p>a<sup>2</sup> × a<sup>3</sup> = (a × a) × (a × a × a) = a<sup>5</sup></p>
          <p>a<sup>3</sup> × a<sup>4</sup> = (a × a × a) × (a × a × a × a) = a<sup>7</sup></p>
        </section>


        <section data-transition="slide" data-background-size="contain" data-background="images/generalization.png" >
          <p>.</p>
        </section>

        <section data-transition="slide">
          <h1>Generalization</h1>
          <p>Relationship that holds between all members of some set of
objects</p>
        </section>

        <section data-transition="slide">
          <h2>Is a mile a long way?</h2>
          <img data-src="images/1_mile.gif" />
        </section>

        <section data-transition="slide">
          <h2>Is a year a large amount of time?</h2>
          <img class="stretch" data-src="images/dec-31-calendar.jpg" />
        </section>

        <section data-transition="slide" data-background-size="contain" data-background="images/context-matters.jpg" >
          <p>.</p>
        </section>

        <section data-transition="slide">
          <h1>It all depends on context</h1>
            <ul>
          <li>A mile is along way if you are an Ant but not if you are flying in an aeroplane.</li>
          <li>A year is a long time for a Mayfly that lives for only 5 minutes. But in geological time it's insignificant.</li>
            <ul>
        </section>

        <section>
          <h1>Training Level</h1>
        </section>

        <section data-transition="slide">
          <h2>What is functional programming?</h2>
          <blockquote>Construct our programs using only pure functions.</blockquote>
          <blockquote>Pure functions have no side effects.</blockquote>
        </section>

        <section data-transition="slide">
          <h1>Why is a function like a pipe?</h1>
          <p>Some thing goes into one end and something else comes out the other end</p>
        </section>

        <section data-transition="slide">
          <p>Simple pipes simple can  be joined together to form complex systems?</p>
          <img class="stretch" data-src="images/complex_pipes.jpg" >
        </section>

        <section data-transition="slide">
          <h2>What's so good about no side effects?</h2>
          <p>It makes it easier to reason about what's going on</p>
        </section>

        <section>
          <h2>It's important that functions like pipes don't leak</h2>
          <img class="stretch"  data-src="images/leaking_pipes.jpg">
        </section>

        <section data-transition="slide">
          <h1>World 1-1</h1>
          <p>Functor Land</p>
        </section>

        <section data-transition="slide">
          <h1>Goomba problem</h1>
          <img data-src="images/Goomba.png">
        </section>

        <section data-transition="slide">
          <h2>How to Defeat a Goomba</h2>
          <img data-src="images/goombacoin.png"/>
          <p>Stomp it and it turns into a coin</p>
          <pre ><code class="scala" data-trim>
case class Coin()
case class Goomba()

def stomp(g:Goomba) = Coin()
          </code></pre>
          <p>The function stomp is our pipe, that transforms from a Goomba to a Coin.</p>
        </section>

        <section data-transition="slide">
          <h2>Luigis vacuum to collect Goombas</h2>
          <img class="stretch" data-src="images/Luigi_Mansion_dark.jpg"/>
          <pre><code class="scala" data-trim>
class Vacuum {
  def collect(g:Goomba) = stomp(s)
}
          </code></pre>
          <pre><code class="scala" data-trim>
val vacuum = new Vacuum()
val goomba = new Goomba()
vacuum.collect(goomba)
//Coin()
          </code></pre>

        </section>

        <section data-transition="slide-in zoom-out">
          <h2>What happens when the Goomba escapes the suction?</h2>
          <pre><code class="scala" data-trim>

val vacuum = new Vacuum()

vacuum.collect(null)

          </code></pre>
        </section>

        <section data-transition="zoom-in" data-background="images/BOOM.png" data-background-size="contain">
          <p>.</p>
        </section>

        <section data-transition="slide">
          <h2>Check For Nulls</h2>
          <pre><code class="scala" data-trim >

class Vacuum {
  def collect(s:Goomba) = if (s == null) null else stomp(s)
}

          </code></pre>
          <p>But then the calling class runs the risk of NullPointer exceptions.</p>
        </section>

        <section data-transition="zoom-in">
          <p>There must be a better way</p>
          <img class="stretch" data-src="images/better_way.jpg"/>
        </section>

        <section data-transition="zoom-in">
          <h2>Solution</h2>
          <p>Put the Goomba in a Cage</p>
          <img class="stretch" data-src="images/goombaincage.png"/>
        </section>

        <section data-transition="slide-in zoom-out">
          <pre ><code class="scala" data-trim>
sealed trait Cage[T]
case class FullCage[T](value: T) extends Cage[T]
case class EmptyCage[T]() extends Cage[T]
object Cage {
  def apply[T](x: T):Cage[T] =
            if (x == null) EmptyCage[T]() else FullCage(x)
}
</code></pre>
<pre class="fragment"><code class="scala" data-trim>
class Vacuum {
  def collect(c:Cage[Goomba]):Cage[Coin] = c match {
    case EmptyCage() => EmptyCage[Coin]()
    case FullCage(s) => FullCage(stomp(s))
  }
}
           </code></pre>

          <pre class="fragment"><code class="scala" data-trim>
val vac = new Vacuum()

vac.collect(Cage(Goomba()))
//FullCage[Coin](Coin())

vac.collect(Cage(null))
//EmptyCage[Coin]()
          </code></pre>
        </section>

        <section data-transition="zoom-in" data-background="images/no_boom_boom.jpg" >
          <p>.</p>
        </section>


        <section data-transition="slide">
          <h1>Can we generalize the Vacuum class?</h1>
          <img class="stretch" data-src="images/cow.jpg" >
        </section>

        <section data-transition="slide">
          <h2>Why limit ourself to just stomping Goombas in the cage?</h2>
          <pre><code class="scala" data-trim>
class Vacuum {

  def collect[A,B](c:Cage[A], f:A => B):Cage[B] = c match {

    case EmptyCage() => EmptyCage[B]()

    case FullCage(s) => FullCage(f(s))

  }
}
        </code></pre>
        </section>

        <section data-transition="slide">
          <p>Turn it into a trait</p>
          <pre ><code class="scala" data-trim>
trait Collector {
  def collect[A,B](c:Cage[A], f:A => B):Cage[B]
}
        </code></pre>
        <pre ><code class="scala" data-trim>
class Vacuum extends Collector {
  def collect[A,B](c:Cage[A], f:A => B):Cage[B] = c match {
    case EmptyCage() => EmptyCage[B]()
    case FullCage(s) => FullCage(f(s))
  }
}

        </code></pre>
        </section>

        <section data-transition="slide">
          <p>Parameterise the trait</p>
          <pre><code class="scala" data-trim>
trait Collector[F[_]] {

  def collect[A,B](c:F[A], f:A => B): F[B]

}
        </code></pre>
        <pre ><code class="scala" data-trim>
object Vacuum extends Collector[Cage] {
  def collect[A,B](c:Cage[A], f:A => B):Cage[B] = c match {
    case EmptyCage() => EmptyCage[B]()
    case FullCage(s) => FullCage(f(s))
  }
}
        </code></pre>
        </section>

        <section data-transition="zoom-in" data-background="images/get_the_funk_out.jpg">
          <p>.</p>
        </section>

        <section data-transition="slide">
          <h1>The Functor</h1>
          <blockquote>A functor is basically for things that can be mapped over.</blockquote>
        </section>

        <section data-transition="slide">
          <h1>The functor definition in Scalaz</h1>
        </code></pre>
        <pre><code class="scala" data-trim>
package scalaz

trait Functor[F[_]] extends InvariantFunctor[F] { self =>
  ...
  /** Lift `f` into `F` and apply to `F[A]`. */
   def map[A, B](fa: F[A])(f: A => B): F[B]
  ...
}
        </code></pre>
        </section>

        <section data-transition="slide">
          <h1>How do you use it?</h1>
          <img class="stretch" data-src="images/vacuumluigicage.png"/>
        <pre ><code class="scala" data-trim>

object CageFunctor extends Functor[Cage] {

  def map[A,B](c:Cage[A])(f:A => B):Cage[B] = c match {
    case EmptyCage() => EmptyCage[B]()
    case FullCage(s) => FullCage(f(s))
  }

}
        </code></pre>
      <pre><code class="scala" data-trim>

CageFunctor.map(Cage(Gummba()))(stomp)
      </code></pre>
      </section>

      <section data-transition="slide">
        <h1>Is there a better way?</h1>
      </section>


      <section data-transition="zoom-in" data-background-size="contain" data-background="images/warpzone.jpg" >
        <p>.</p>
      </section>

      <section data-transition="slide">
        <h1>Type classes in 60 seconds</h1>
        <img class="stretch" data-src="images/go_baby.jpg"/>
      </section>

      <section data-transition="slide">
        <h2>Why?</h2>
        <ul>
          <li >Extend existing classes</li>
          <li >Without inheritance</li>
          <li >Without altering original source</li>
          <li >Keeps concerns seperate</li>
        </ul>
      </section>

      <section data-transition="slide">
        <h2>How?</h2>
        <h3>3 components</h3>
        <ol>
          <li >The type class</li>
          <li >Instances for particular types</li>
          <li >Interface methods for the api</li>
        </ol>
      </section>

      <section data-transition="slide">
        <h3>The Type Class</h3>
        <p>Provide a generic type of what we want to implement.</p>
        <pre ><code class="scala" data-trim>
trait ProtoBuffWriter[A] {
  def write(value: A): Array[Byte]
}
          </code></pre>
      </section>

      <section data-transition="slide">
        <h3>Type Class Instances</h3>
        <p>Provide implementations for the types we care about.</p>
        <p>Create concrete implementations of the type class and mark them as implicit.</p>
        <pre  ><code class="scala" data-trim>
object DefaultProtoBuffWriters {
  implicit val coinWriter = ProtoBuffWriter[Coin] { .... }
  implicit val goombaWriter = ProtoBuffWriter[Goomba] { .... }
  // etc ...
}
          </code></pre>
      </section>

      <section data-transition="slide">
        <h3>Interfaces</h3>
        <p>What is exposed to clients.</p>
        <p>Generic methods that accept instances of the type class as implicit params.</p>
        <h3 class="fragment">Two ways of doing it</h3>
      </section>

      <section data-transition="slide">
        <h3>Interface Objects</h3>
        <p>All methods in a singleton.</p>
        <pre ><code class="scala" data-trim>
object ProtoBuff {
  def toProtoBuff[A](value: A)
  (implicit writer: ProtoBuffWriter[A]): Array[Byte] {
    writer.write(value)
  }
}
          </code></pre>
        <pre  ><code class="scala" data-trim>
import DefaultProtoBuffWriters._
val protoBuff: Array[Byte] = ProtoBuff.toProtoBuff(Coin())
        </code></pre>
      </section>

      <section data-transition="slide">
        <h3>Interface Syntax</h3>
        <p>Pimp existing types with interface methods.</p>
        <pre  ><code class="scala" data-trim>
object ProtoBuffSyntax {
  implicit class ProtoBuffWriter[A](value: A) {
    def toProtoBuff(implicit writer: ProtoBuffWriter[A])
    : Array[Byte] = {
      writer.write(value)
    }
  }
}
        </code></pre>
        <pre  ><code class="scala" data-trim>
import DefaultProtoBuffWriters._
import ProtBuffSyntax._

val protoBuff: Array[Byte] = Coin().toProtoBuff
        </code></pre>
      </section>

      <section data-transition="slide">
        <h3>What about scalaz?</h3>
        <p>Pimp existing types</p>
        <p>Uses the Type classes in Ops classes</p>
        <p>Ops classes use the Type class and provide more methods</p>
        <pre ><code class="scala" data-trim>
import scala.language.implicitConversions
sealed trait ToProtoBuffWriterOps {
  implicit def ToProtoBuffWriterOps[A](v: A)
    (implicit F: ProtoBuffWriter[A]) = new ProtoBuffWriterOps(v)
}

object protoBuffWriter extends ToProtoBuffWriterOps

        </code></pre>
        <pre class="fragment"> <code class="scala" data-trim>
import sun.misc.BASE64Encoder //for example only
class ProtoBuffWriterOps[A](val self: A)
(implicit val F: ProtoBuffWriter[A]) {
  def write(value: A) = F.write(value)
  def writeBase64(value: A) =
        new BASE64Encoder().encodeBuffer(write(value))
}
        </code></pre>
      </section>


      <section data-transition="slide">
        <h1>!!Warning!!</h1>
        <p>Implicits like warp pipes can be dangerous</p>
        <img class="fragment" data-src="images/warp-zone-danger.jpg"/>
      </section>

      <section data-transition="slide">
        <h2>Scalaz Functor Syntax: ToFunctorOps</h2>
        <p>scalaz.syntax.FunctorSyntax.scala</p>
      <pre ><code class="scala" data-trim>
trait ToFunctorOps extends ToFunctorOps0 with ToInvariantFunctorOps
{
implicit def ToFunctorOps[F[_],A](v: F[A])(implicit F0: Functor[F])
= new FunctorOps[F,A](v)
...
}
        </code></pre>
        <p>Given a F[A] and a implicit Functor[F] in scope add all the FunctorOps to F[A]</p>
      </section>

      <section data-transition="slide">
        <h2>Scalaz Functor Syntax: FunctorOps</h2>
        <p>scalaz.syntax.FunctorSyntax.scala</p>
      <pre ><code class="scala" data-trim>
final class FunctorOps[F[_],A] private[syntax]
(val self: F[A])(implicit val F: Functor[F]) extends Ops[F[A]] {
...
  final def map[B](f: A => B): F[B] = F.map(self)(f)
...
}
        </code></pre>
        <p >Given a F[A] and a implicit Functor[F] in scope delegate the map method to the Functor[F] in scope</p>
      </section>

      <section data-transition="slide">
        <h2>Finally</h2>
        <p>scalaz.syntax package object extends Syntaxes</p>
        <pre ><code class="scala" data-trim>
trait Syntaxes {
  object functor extends ToFunctorOps
}
import scalaz.syntax.functor
          </code></pre>
      </section>

      <section data-transition="slide">
        <h2>Cage Functor again</h2>
        <p>scalaz.syntax.FunctorSyntax.scala</p>
      <pre ><code class="scala" data-trim>
import scalaz.Functor
implicit object CageFunctor extends Functor[Cage] {

  def map[A,B](c:Cage[A])(f:A => B):Cage[B] = c match {
    case EmptyCage() => EmptyCage[B]()
    case FullCage(s) => FullCage(f(s))
  }
}
        </code></pre>
        <pre ><code class="scala" data-trim>
import scalaz.syntax.functor
Cage(Goomba()).map(stomp)

          </code></pre>
<img data-src="images/vacuumluigicoin.png" class="stretch">

      </section>

      <section data-transition="slide">
        <h1>The Functor Laws</h1>
        <p>Mapping preserves identity</p>
        <blockquote>If we map the id function over a functor, the functor that we get back should be the same as the original functor</blockquote>
        <p>Mapping respects composition</p>
        <blockquote>Composing two functions and then mapping the resulting function over a functor should be the same as first mapping one function over the functor and then mapping the other one</blockquote>
      </section>


      <section data-transition="slide">
        <h2>Does your functor break laws?</h2>
      <pre ><code class="scala" data-trim>
import org.scalacheck.Arbitrary
import org.specs2.scalaz.Spec
import scalaz.Equal
import scalaz.scalacheck.ScalazProperties

class CageFunctorSpec extends Spec {
  implicit val abrCage = Arbitrary[Cage[Int]] {
    for {
      ns <- Arbitrary.arbInt.arbitrary
    } yield Cage(ns)
  }

  implicit val cageEqual = Equal.equal[Cage[Int]]((a, b) => a == b)

  checkAll(ScalazProperties.functor.laws[Cage])
}
      </code></pre>
      <pre ><code class="scala" data-trim>
val scalazVersion = "7.1.3"

libraryDependencies ++= Seq(
  "org.scalaz"    %% "scalaz-core"   % scalazVersion,
  "org.specs2"    %% "specs2-core"   % "2.4"           % "test",
  "org.typelevel" %% "scalaz-specs2" % "0.3.0"         % "test"
)
    </code></pre>
      </section>

      <section data-transition="slide">
        <h2>Remember the three points?</h2>
        <ul>
        <li >Abstraction: Functor is a abstract concept</li>
        <li >Generalization: There is a set of objects that can be mapped over</li>
      </ul>
      <p class="fragment">What about the context?</p>
      </section>

      <section data-transition="slide">
        <h1>Context</h1>
        <p>Context is the environment the function is applied in.</p>

      </section>

      <section data-transition="slide">
        <img data-src="images/function_in_context.png" class="stretch">
      </section>

      <section data-transition="slide">
        <h1>Meet some more Contexts</h1>
      </section>

      <section data-transition="slide">
        <h3>scala.Option</h3>
        <pre ><code class="scala" data-trim>
sealed abstract class Option[+A] extends Product with Serializable {
...
final def map[B](f: A => B): Option[B] =
    if (isEmpty) None else Some(f(this.get))
...
}
      </code></pre>
      <p >Scalaz provides implicits to convert Option to a Functor trait</p>
      <pre ><code class="scala" data-trim>
import scalaz.std.option._
import scalaz.std.anyVal._

checkAll(ScalazProperties.functor.laws[Option])
    </code></pre>
      <p >Option is context for a computation that might fail</p>
      </section>

      <section data-transition="slide">
        <h3>List are also functors</h3>
        <pre ><code class="scala" data-trim>
sealed abstract class List[+A] { ....
final def map[B](f: (A) ⇒ B): List[B]
  ...
}
        </code></pre>
<p>Scalaz provides implicits to convert List to a Functor trait</p>
<pre ><code class="scala" data-trim>
import scalaz.std.list._
import scalaz.std.anyVal._
import org.specs2.scalaz.Spec
import scalaz.scalacheck.ScalazProperties

class ListFunctorSpec extends Spec {
  checkAll(ScalazProperties.functor.laws[List])
}
</code></pre>
        <p>If 6 is deterministic and having one value.<br>
          The List context such as List(1,10,3,4) can be thought of as having multipule values at once.
        </p>
        <p>Or no values if empty</p>
      </section>

      <section data-transition="slide">
        <h3>Disjunctions are Functors</h3>
        <pre class="stretch" ><code class="scala" data-trim>
import org.specs2.scalaz.Spec
import scalaz.scalacheck.ScalazProperties

class ListFunctorSpec extends Spec {
  implicit val abrStringIntEither = Arbitrary[\/[String, Int]] {
    for {
      ns <- Arbitrary.arbInt.arbitrary
    } yield \/-(ns)
  }

  implicit val disjuncEqual =
    Equal.equal[\/[String, Int]]((a, b) => { (a,b) match {
      case(-\/(l1), -\/(l2)) => l1 == l2
      case(\/-(r1), \/-(r2)) => r1 == r2
      case _ => false
    }
  })
  //left type param is fixed
  checkAll(ScalazProperties.functor.laws[({type λ[α] = \/[String, α]})#λ])
}
      </code></pre>
      </section>


      <section data-transition="slide">
        <h1>So why is this so handy?</h1>
      </section>

      <section data-transition="slide">
        <h2>Ordinary functions are simpler to:</h2>
          <ul>
            <li>read</li>
            <li>write</li>
            <li>use</li>
            <li>reason about</li>
          </ul>
      </section>

      <section data-transition="slide">
        <h2>Functions in a context have useful properties</h2>
        <p>Functors let us write ordinary functions</p>
        <p>Then promote those functions into every context that might need that code</p>
        <p>As new contexts arise we just define new functors to promote our ordinary code to work in those contexts.</p>
      </section>

      <section data-transition="slide">
        <pre class="stretch"><code class="scala" data-trim>
///Ordinary function
def stomp(g:Goomba) = g.stomp()

///The context
sealed trait Cage[T]
case class FullCage[T](value: T) extends Cage[T]
case class EmptyCage[T]() extends Cage[T]
object Cage {
  def apply[T](x: T):Cage[T] =
            if (x == null) EmptyCage[T]() else FullCage(x)
}

///Promote into context
import scalaz.Functor
implicit object CageFunctor extends Functor[Cage] {
  def map[A,B](c:Cage[A])(f:A => B):Cage[B] = c match {
    case EmptyCage() => EmptyCage[B]()
    case FullCage(s) => FullCage(f(s))
  }
}

///use
import scalaz.syntax.functor
Cage(Goomba()).map(stomp)

</code></pre>
      </section>

  <section data-transition="zoom-in" data-background-size="contain" data-background="images/world-1-1-flag.jpg" >
    <p>.</p>
  </section>


  <section data-transition="slide">
    <h1>World 1-2</h1>
    <p>Apply Land</p>
  </section>

  <section data-transition="slide">
    <h2>Piranha Plant</h2>
    <img class="stretch" data-src="images/Piranha_Plant.png">
  </section>

  <section data-transition="slide">
    <h2>Piranha Plant</h2>
    <pre><code class="scala" data-trim>
case class Coin()
case class Fireball()
case class PiranhaPlant()

def shoot(plant:PiranhaPlant, fireball:Fireball): Coin = Coin()
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>The plant is generated from a unreliable source</h3>
    <p>Wrap the plant in a Cage and map over it?</p>
<pre ><code class="scala" data-trim>
Cage(PiranhaPlant()).map(shoot _)
    </code></pre>
    <pre  class="fragment"><code class="scala" data-trim>
      <console>:31: error: type mismatch;
found   : (PiranhaPlant, Fireball) => Coin
required: PiranhaPlant => ?
            Cage(PiranhaPlant()).map(shoot _)
        </code></pre>
  </section>

  <section data-transition="slide" data-background-size="contain" data-background="images/curry.jpg" >
    <h2 ><font color="#f08">Curring</font></h2>
  </section>

  <section data-transition="slide">
    <h2>Curring is partial application</h2>
    <p>Translating the evaluation of a function that takes multiple arguments
       into evaluating a sequence of functions, each with a single argument
    <pre ><code class="scala" data-trim>
(shoot _).curried
//res41: PiranhaPlant => (Fireball => Coin) = <function1>
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Map the curried shoot function</h3>
    <pre ><code class="scala" data-trim>
Cage(PiranhaPlant()) map {shoot _}.curried
//Cage[Fireball => Coin] = ...
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>What if the fireball parameter generation is in a context?</h3>
    <p >Functor only support mapping functions over functor</p>
    <pre  ><code class="scala" data-trim>
def map[A, B](fa: F[A])(f: A => B): F[B]
    </code></pre>
    <p>We need to map function in a functor over a value in a functor</p>
    <p>
  </section>

  <section data-transition="slide">
    <h3>Apply</h3>
<pre ><code class="scala" data-trim>
package scalaz
trait Apply[F[_]] extends Functor[F] { self =>
  ////
  def ap[A,B](fa: => F[A])(f: => F[A => B]): F[B]
  ...
}
</code></pre>

<pre ><code class="scala" data-trim>
package scalaz
package syntax

final class ApplyOps[F[_],A] private[syntax](val self: F[A])
(implicit val F: Apply[F]) extends Ops[F[A]] {
  final def <*>[B](f: F[A => B]): F[B] = F.ap(self)(f)
...
}

trait ToApplyOps extends ToApplyOps0 with ToFunctorOps {
  implicit def ToApplyOps[F[_],A](v: F[A])(implicit F0: Apply[F]) =
    new ApplyOps[F,A](v)
...
}
</code></pre>

  </section>

  <section data-transition="slide">
    <h3>What would our vacuum look like?</h3>
    <pre ><code class="scala" data-trim>
implicit object CageApply extends Apply[Cage]{
  override def ap[A, B](fa: => Cage[A])
  (fab: => Cage[(A) => B]): Cage[B] =  fab match {

    case FullCage(f) => fa match {
      case FullCage(x) => FullCage(f(x))
      case EmptyCage()    => EmptyCage[B]()
    }
    case EmptyCage()    => EmptyCage[B]()
  }

  override def map[A, B](fa: Cage[A])
      (f: (A) => B): Cage[B] = CageFunctor.map(fa)(f)
}
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>How would you use it?</h3>
    <pre ><code class="scala" data-trim>
val partialShoot = Cage(PiranhaPlant()) <*> Cage((shoot _).curried)

val optCoin = Cage(Fireball()) <*> partialShoot
//optCoin: Cage[Coin] = FullCage(Coin())


val optCoin = EmptyCage[Fireball]() <*> partialShoot
//optCoin: Cage[Coin] = EmptyCage[Coin]()
    </code></pre>



  </section>

  <section data-transition="slide">
    <h3>What have we done?</h3>
    <p>Taken a function that takes two values.</p>
    <p>Turned it into a function that takes two values in a context.</p>
  </section>

  <section data-transition="slide">
    <h3>Testing The Laws</h3>
    <pre class="stretch" ><code class="scala" data-trim>
import org.scalacheck.Arbitrary
import org.specs2.scalaz.Spec
import scalaz.Equal
import scalaz.scalacheck.ScalazProperties

class CageApplySpec extends Spec {

  implicit val abrCage = Arbitrary[Cage[Int]] {
    for {
      ns <- Arbitrary.arbInt.arbitrary
    } yield Cage(ns)
  }

  implicit val arbCageIntToInt = Arbitrary[Cage[Int => Int]] {
    for{
      multi <- Arbitrary.arbInt.arbitrary
    } yield Cage((x:Int) => x * multi)
  }

  implicit val cageEqual = Equal.equal[Cage[Int]]((a, b) => a == b)

  checkAll(ScalazProperties.apply.laws[Cage])
}
    </code></pre>

  </section>

  <section data-transition="slide">
    <h3>Option Apply: OptionInstances</h3>
    <pre ><code class="scala" data-trim>
package scalaz
package std

override def ap[A, B](fa: => Option[A])
  (f: => Option[A => B]) = f match {
    case Some(f) => fa match {
      case Some(x) => Some(f(x))
      case None    => None
    }
    case None    => None
  }
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Shoot that Piranha Plant</h3>
    <pre ><code class="scala" data-trim>
import scalaz.std.option._

val partialShoot =
  Option(PiranhaPlant()) <*> Option((shoot _).curried)
val optCoin = Option(Fireball()) <*> partialShoot
//optCoin: Option[Coin] = Some(Coin())
    </code></pre>
    <p class="That's a bit hard to follow">
  </section>

  <section data-transition="slide">
    <h3>Some nicer syntax</h3>
    <pre ><code class="scala" data-trim>
import scalaz.std.option._
import scalaz.syntax.apply._

^(Option(PiranhaPlant()), Option(Fireball()))(shoot)
//res69: Option[Coin] = Some(Coin())

import scalaz.Apply
Apply[Option]
.lift2(shoot)(Option(PiranhaPlant()), Option(Fireball()))
//res70: Option[Coin] = Some(Coin())

    </code></pre>
  </section>


  <section data-transition="slide">
    <h3>List as an Apply Context</h3>
    <pre ><code class="scala" data-trim>
val partial = List(PiranhaPlant(), PiranhaPlant(),
  PiranhaPlant()) <*> List((shoot _).curried)
List(Fireball()) <*> partial
//res23: List[Coin] = List(Coin(), Coin(), Coin())

  </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Disjunction as an Apply</h3>
    <pre ><code class="scala" data-trim>
    \/.right[String, Goomba](Goomba()) <*>
      \/.right[String, Goomba => Coin]((_:Goomba) => Coin())
  //res: scalaz.\/[String,Coin] = \/-(Coin())
  </code></pre>
  </section>

  <section data-transition="slide">
    <p>Apply lets you take a function that takes values and turn it into a function that takes values in a context.</p>
    <p>Write the code once and reuse it in the context you need</p>
  </section>

  <section data-transition="slide">
    <h2>Remember the three points?</h2>
    <ul>
    <li >Abstraction: Apply is a abstract concept</li>
    <li >Generalization: There is a set of objects that implement the Apply trait</li>
    <li >Context: How the funciton is used depends on the Apply Specialization we are using</li>
  </ul>
  </section>

  <section data-transition="zoom-in" data-background-size="contain" data-background="images/level_2_flag.png" >
    <p>.</p>
  </section>

  <section data-transition="slide">
    <h1>World 1-3</h1>
    <p>Applicative</p>
  </section>

  <section data-transition="slide">
    <h2>Koopa Paratroopa</h2>
    <img class="stretch" data-src="images/KoopaPara.png">
  </section>

  <section data-transition="slide">
    <h2>Has to be:</h2>
    <ol>
      <li>Koopa Paratroopa shot to a Koopa Troopa</li>
      <li>Koopa Troopa is shot to a Shell</li>
      <li>Shell is shot to a Coin</li>
    </ol>
    <img data-src="images/koopa.png">
  </section>


  <section data-transition="zoom-in" data-background-size="contain" data-background="images/talk_is_cheap.jpg" >
    <p>.</p>
  </section>

  <section data-transition="slide">
    <h3>The code</h3>
    <pre><code class="scala" data-trim>
case class KoopaParatroopa()
case class KoopaTroopa()
case class Shell()
case class Coin()
case class Fireball()

def shootKP(fb: Fireball, kt:KoopaParatroopa) = KoopaTroopa()
def shootKT(fb: Fireball, kt:KoopaTroopa) = Shell()
def shootS(fb: Fireball, kt:Shell) = Coin()

  </code></pre>
  <pre class="fragment"><code class="scala" data-trim>
val cagedKoopa = ^(Cage(Fireball()),
  Cage(KoopaParatroopa()))(shootKP)
val cagedShell = ^(Cage(Fireball()), cagedKoopa)(shootKT)
val cagedCoin = ^(Cage(Fireball()), cagedShell)(shootS)
//cagedCoin: Cage[Coin] = FullCage(Coin())
</code></pre>

  </section>

  <section data-transition="slide">
    <h3>Applicative</h3>
    <pre><code class="scala" data-trim>
trait Applicative[F[_]] extends Apply[F] { self =>
  ////
  def point[A](a: => A): F[A]
  ...
}
  </code></pre>
  <pre class="fragment"><code class="scala" data-trim>
implicit object CageApplicative extends Applicative[Cage] {
  override def ap[A, B](fa: => Cage[A])
      (fab: => Cage[(A) => B]): Cage[B] =  fab match {
      case FullCage(f) => fa match {
        case FullCage(x) => FullCage(f(x))
        case EmptyCage()    => EmptyCage[B]()
      }
      case EmptyCage()    => EmptyCage[B]()
  }

  override def point[A](a: => A): Cage[A] = Cage(a)
}

</code></pre>
<p class="fragment">We no longer need to define map</p>
  <pre class="fragment"><code class="scala" data-trim>
override def map[A, B](fa: F[A])(f: A => B): F[B] =
  ap(fa)(point(f))
  </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Using applicative</h3>
    <pre><code class="scala" data-trim>
import scalaz.syntax.applicative._
val cagedKoopa = ^(Fireball().point[Cage],
    KoopaParatroopa().point[Cage])(shootKP)
val cagedShell = ^(Fireball().point[Cage], cagedKoopa)(shootKT)
val cagedCoin = ^(Fireball().point[Cage], cagedShell)(shootS)

//cagedCoin: Cage[Coin] = FullCage(Coin())
  </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Same code different context</h3>
    <pre><code class="scala" data-trim>
val cagedKoopa = ^(Fireball().point[List],
  KoopaParatroopa().point[List])(shootKP)
val cagedShell = ^(Fireball().point[List], cagedKoopa)(shootKT)
val cagedCoin = ^(Fireball().point[List], cagedShell)(shootS)

//cagedCoin: List[Coin] = List(Coin())
  </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Remember</h3>
    <ol>
      <li>Abstraction: The Applicative</li>
      <li>Generalisation: The Applicative trait</li>
      <li>The context: Different behaviours for the same code</li>
    </ol>
  </section>

  <section data-transition="zoom-in" data-background-size="contain" data-background="images/level_3_flag.jpg" >
    <p>.</p>
  </section>

  <section data-transition="slide">
    <h1>World 1-4</h1>
    <p>Monad</p>
  </section>

  <section data-transition="slide">
    <h2>Bowser</h2>
    <img class="stretch" data-src="images/bowser.gif">
  </section>

  <section data-transition="slide">
    <h3>The Rules</h3>
    <p>Mario can hit Bowser</p>
    <p>Bowser can hit Mario</p>
    <p>Mario dies if at any point hits on Mario > hits on Bowser + 2</p>
    <img class="stretch" data-src="images/mario_v_bow1.png">
  </section>

  <section data-transition="slide">
    <h3>First Try</h3>
    <pre><code class="scala" data-trim>
case class Hits(mario:Int, bowser:Int)

def hitBowser(hits: Hits) = hits.copy(bowser = hits.bowser + 1)
def hitMario(hits: Hits) = hits.copy(mario = hits.mario + 1)
  </code></pre>
<pre class="fragment"><code class="scala" data-trim>

def marioWins =  hitMario _ andThen hitBowser
  andThen hitBowser andThen hitBowser

marioWins(Hits(0,0))
//Hits = Hits(1,3)
</code></pre>
  </section>

  <section data-transition="slide">
    <h3>How about this?</h3>
<pre><code class="scala" data-trim>

def marioWins =  hitMario _ andThen hitMario andThen
  hitMario andThen hitBowser andThen
  hitBowser andThen hitBowser

marioWins(Hits(0,0))
//hits = Hits(3,3)
marioWins(Hits(3,0))
//marioWins(Hits(6,3))
</code></pre>

<p class="fragment">Mario should have died</p>
  </section>

  <section data-transition="slide">
    <h3>Failing the computation?</h3>
<pre><code class="scala" data-trim>
Hits => Cage[Hits]
</code></pre>

<pre><code class="scala" data-trim>
def hitMario2(hits: Hits):Cage[Hits] =  hits match {
  case ko:Hits if ko.mario + 1 - ko.bowser > 2 => EmptyCage[Hits]()
  case Hits(mario, bowser) => Cage(Hits(mario + 1, bowser))
}

def hitBowser2(hits: Hits):Cage[Hits] = hits match {
  case ko:Hits if  ko.mario + 1- ko.bowser > 2 => EmptyCage[Hits]()
  case Hits(mario, bowser) => Cage(Hits(mario, bowser + 1))
}
</code></pre>
<p class="fragment">What's the problem?</p>
  </section>

  <section data-transition="slide">
    <h3>The Hits are trapped in the Cage!!</h3>
    <img class="stretch" data-src="images/trapped.jpg">
  </section>

  <section data-transition="slide">
    <h1>Monad</h1>
  </section>

  <section data-transition="slide">
    <h2>Monad</h2>
    <pre><code class="scala" data-trim>
trait Bind[F[_]] extends Apply[F] { self =>
  def bind[A, B](fa: F[A])(f: A => F[B]): F[B]

  override def ap[A, B](fa: => F[A])(f: => F[A => B]): F[B] = {
    lazy val fa0 = fa
    bind(f)(map(fa0))
  }
  ...
}
trait Monad[F[_]] extends Applicative[F] with Bind[F] { self =>
...
  override def map[A,B](fa: F[A])(f: A => B) = bind(fa)(a => point(f(a)))
...
}
    </code></pre>
    <p>Define point and bind and we get map and ap for free</p>
  </section>

  <section data-transition="slide">
    <h2>Cage Monad</h2>
    <pre><code class="scala" data-trim>
implicit object CageMonad extends Monad[Cage]{
  override def bind[A, B](fa: Cage[A])(f: (A) => Cage[B]):
    Cage[B] = fa match {
    case FullCage(a) => f(a)
    case EmptyCage() => EmptyCage[B]()
  }

  override def point[A](a: => A): Cage[A] = Cage(a)
}
    </code></pre>
  </section>

  <section data-transition="slide">
    <h2>BindOps</h2>
    <pre><code class="scala" data-trim>
final class BindOps[F[_],A] private[syntax](val self: F[A])
  (implicit val F: Bind[F]) extends Ops[F[A]] {

  ...

  def flatMap[B](f: A => F[B]) = F.bind(self)(f)

  def >>=[B](f: A => F[B]) = F.bind(self)(f)
  ...
}

trait ToBindOps extends ToBindOps0 with ToApplyOps {
  implicit def ToBindOps[F[_],A](v: F[A])(implicit F0: Bind[F]) =
    new BindOps[F,A](v)
}
    </code></pre>
  </section>

  <section data-transition="slide">
    <h2>Now</h2>
    <pre><code class="scala" data-trim>
import scalaz.syntax.monad._

Cage(Hits(0,0)) >>=  hitMario2 >>= hitMario2 >>=
  hitMario2 >>= hitBowser2 >>= hitBowser2 >>= hitBowser2
//Cage[Hits] = EmptyCage()
Cage(Hits(0,2)) >>=  hitMario2 >>= hitMario2 >>=
  hitMario2 >>= hitBowser2 >>= hitBowser2 >>= hitBowser2
//Cage[Hits] = FullCage(Hits(3,5))
    </code></pre>

  <img data-src="images/mario_v_bow2.png">
  </section>

  <section data-transition="slide">
    <h2>For comprehension flat map</h2>

    <pre class="fragment"><code class="scala" data-trim>
val x  = for {
  r1 <- Cage(Hits(0,0))
  r2 <- hitMario2(r1)
  r3 <- hitMario2(r2)
  r4 <- hitMario2(r3)
  r5 <- hitBowser2(r4)
  r6 <- hitBowser2(r5)
  result <- hitBowser2(r6)
} yield result
    </code></pre>
  </section>

  <section data-transition="slide">
    <h2>Other Monads</h2>
    <pre><code class="scala" data-trim>
def addTwo(x:Int) = Some(x + 2)
1.some >>= addTwo
//addTwo: (x: Int)List[Int]

def addTwo(x:Int) = List(x + 2)
List(1,2,3) >>= addTwo
//List[Int] = List(3, 4, 5)
    </code></pre>
    <p>Reader Monad</p>
    <p>Writer Monad</p>
    <p>State Monad</p>
  </section>

  <section data-transition="slide">
    <h2>Monad Laws</h2>
    <p>Inherit the laws from Bind and Applicative</p>
    <ul>
      <li>Right Identity</li>
      <li>Left Identity</li>
    </ul>
  </section>

  <section data-transition="slide">
    <h2>Hang on I can't reuse these functions</h2>
    <pre class="fragment"><code class="scala" data-trim>
def hitMario3[F[_]](hits: Hits)(implicit F0: Monad[F])
  :F[Hits] =  hits match {
    case ko:Hits if ko.mario + 1 - ko.bowser > 2 =>
      F0.point(null: Hits)
    case Hits(mario, bowser) =>
      F0.point(Hits(mario + 1, bowser))
}
  </code></pre>
  <pre class="fragment"><code class="scala" data-trim>
def hitBowser3[F[_]](hits: Hits)(implicit F0: Monad[F])
  :F[Hits] = hits match {
    case ko:Hits if  ko.mario + 1- ko.bowser > 2 =>
      F0.point(null: Hits)
    case Hits(mario, bowser) =>
    F0.point(Hits(mario, bowser + 1))
}
</code></pre>
<pre class="fragment"><code class="scala" data-trim>
Cage(Hits(1,2)) >>= hitMario3[Cage]
//Cage[Hits] = FullCage(Hits(2,2))
Cage(Hits(1,2)) >>= hitBowser3[Cage]
//Cage[Hits] = FullCage(Hits(1,3))
  </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Monad</h3>
    <p>Lets us call a function that takes a value and returns a value
      in a context with a value in a context.</p>
  </section>

  <section data-transition="slide">
    <h3>Remember</h3>
    <ol>
      <li>Abstraction: The Monad</li>
      <li>Generalisation: The Monad trait</li>
      <li>The context: Different behaviours for the same code</li>
    </ol>
  </section>

  <section data-transition="slide">
    <h3>Summary</h3>
    <ol>
      <p>Functor</p>
        <pre><code class="scala" data-trim>
        def map[A, B](fa: F[A])(f: A => B): F[B]
        </code></pre>
      <p>Apply</p>
        <pre><code class="scala" data-trim>
        def ap[A,B](fa: => F[A])
        (f: => F[A => B]): F[B]
        </code></pre>
      <p>Applicative</p>
        <pre><code class="scala" data-trim>
        def point[A](a: => A): F[A]
        </code></pre>

      <p>Monad</p>
      <pre><code class="scala">def bind[A, B](fa: F[A]) (f: A => F[B]): F[B]      </code></pre>
  </section>

  <section data-transition="slide">
    <h1>References</h1>
    <ul>
      <li>Learn you a Haskell for Greater Good <a href="http://learnyouahaskell.com/">http://learnyouahaskell.com/</a></li>
      <li>Leaning Scalaz <a href="http://eed3si9n.com/learning-scalaz/">http://eed3si9n.com/learning-scalaz/</a></li>
      <li>Functional Programming in Scala <a href="https://www.manning.com/books/functional-programming-in-scala">https://www.manning.com/books/functional-programming-in-scala</a></li>
      <li>Bartosz Blog <a href="http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/</a></li>
    </ul>
  </section>

  <section data-transition="zoom-in" data-background-size="contain" data-background="images/super_mario_bros_nes_end_screen.png" >
    <p>.</p>
  </section>

</div>
