<div class="slides" id="slides">
        <section data-transition="slide">
        <h1>Functors, Apply, Applicaive and Monads</h1>
        </section>

        <section data-transition="slide">
          <h2>That's just dull</h2>
        </section>

        <section data-transition="slide">
          <h2>So let's try instead ...</h2>
        </section>

        <section data-transition="slide">
          <h1 style="text-align: right;"><b>Rescuing Princess <font color="#f08">Purity</font> From Castle Side Effect</b></h1>
            <img data-src="images/start_screen.jpg"/>
        </section>

        <section data-transition="slide">
          <h1>Why should you care?</h1>
          <p class="fragment">How do Functors, Apply, Applicative and Monad help you achive early and continous delivery of software?</p>
        </section>

        <section data-transition="slide">
          <h1>3 Questions</h1>
        </section>

        <section data-transition="slide">
          <h1>1</h1>
        </section>

        <section data-transition="slide">
          <h2>If a pizza costs $16 and you buy two how much do you spend?</h2>
          <img data-src="images/mario_pizza.jpg" />
        </section>

        <section data-transition="slide">
          <h2>A mario kart costs $20 per day to rent. How much does it cost to rent for two days?</h2>
          <img data-src="images/monkey_cart.gif" />
        </section>

        <section data-transition="slide">
          <h2>Don't just think about the maths</h2>
          <p class="fragment">Think about the process you are going through before you get to the maths.</p>
          <p class="fragment">What information are you keeping and what information are you dropping?</p>
        </section>

        <section data-transition="slide" data-background-size="contain" data-background="images/kandinsky.comp-8.jpg" >
        </section>

        <section data-transition="slide">
          <h1>Abstraction</h1>
          <p class="fragment">Abstraction is an emphasis on the idea, qualities and properties rather than the particulars</p>
          <p class="fragment">The importance of abstraction is derived from its ability to hide irrelevant details</p>
          <p class="fragment">It doesn't matter if its pizza, mario carts or anything else we take the cost and muliply it by some factor.</p>
        </section>

        <section data-transition="slide">
          <h1>2</h1>
        </section>

        <section data-transition="slide">
          <h2>What is the realation ship between a pologon:</h2>
          <ul>
            <li class="fragment">A 3 sided triangle</li>
            <li class="fragment">A 4 sided quadrilateral</li>
          </ul>
        </section>

        <section data-transition="slide">
          <h2>What has a<sup>m</sup> × a<sup>n</sup> = a<sup>m+n</sup> got in common with:</h2>
          <p class="fragment">a<sup>2</sup> × a<sup>3</sup> = (a × a) × (a × a × a) = a<sup>5</sup></p>
          <p class="fragment">a<sup>3</sup> × a<sup>4</sup> = (a × a × a) × (a × a × a × a) = a<sup>7</sup></p>
        </section>


        <section data-transition="slide" data-background-size="contain" data-background="images/generalization.png" >
        </section>

        <section data-transition="slide">
          <h1>Generalization</h1>
          <p class="fragment">Relationship that holds between all members of some set of
objects</p>
        </section>

        <section data-transition="slide">
          <h1>3</h1>
        </section>

        <section data-transition="slide">
          <h2>Is a mile a long way?</h2>
          <img data-src="images/1_mile.gif" />
        </section>

        <section data-transition="slide">
          <h2>Is a year a large amount of time?</h2>
          <img class="stretch" data-src="images/dec-31-calendar.jpg" />
        </section>

        <section data-transition="slide" data-background-size="contain" data-background="images/context-matters.jpg" >
        </section>

        <section data-transition="slide">
          <h1>It all depends on context</h1>
            <ul>
          <li class="fragment">A mile is along way if you are an Ant but not if you are flying in an aeroplane.</li>
          <li class="fragment">A year is a long time for a Mayfly that lives for only 5 minutes. But in geological time it's insignificant.</li>
            <ul>
        </section>

        <section>
          <h1>Training Level</h1>
        </section>

        <section data-transition="slide">
          <h2>What is functional programming?</h2>
          <blockquote class="fragment">Construct our programs using only pure functions.</blockquote>
          <blockquote class="fragment">Pure functions have no side effects.</blockquote>
        </section>

        <section data-transition="slide">
          <h1>Why is a funciton like a pipe?</h1>
          <p class="fragment">Some thing goes into one end and something else comes out the other end</p>
        </section>

        <section data-transition="slide">
          <p>Simple pipes simple can  be joined together to form complex systems?</p>
          <img class="stretch" data-src="images/complex_pipes.jpg">
        </section>

        <section data-transition="slide">
          <h2>What's so good about no side effects?</h2>
          <p class="fragment">It makes it easier to reason about what's going on</p>
        </section>

        <section>
          <h2>It's important that functions like pipes don't leak</h2>
          <img class="stretch"  data-src="images/leaking_pipes.jpg">
        </section>

        <section data-transition="slide">
          <h1>World 1-1</h1>
          <p>Functor Land</p>
        </section>

        <section data-transition="slide">
          <h1>Goomba problem</h1>
          <img data-src="images/Goomba.png">
        </section>

        <section data-transition="slide">
          <h2>How to Defeat a Goomba</h2>
          <p class="fragment">Stomp it and it turns into a coin</p>
          <pre class="fragment" ><code class="scala" data-trim>
case class Coin()
case class Goomba()

def stomp(g:Goomba) = Coin()
          </code></pre>
          <p class="fragment" >The function stomp is our pipe, that transforms from a Goomba to a Coin.</p>
        </section>

        <section data-transition="slide">
          <h2>Luigis vacuum to collect Goombas</h2>
          <img class="stretch" data-src="images/Luigi_Mansion_dark.jpg"/>
          <pre class="fragment" ><code class="scala" data-trim>
class Vacuum {
  def collect(g:Goomba) = stomp(s)
}
          </code></pre>
          <pre class="fragment" ><code class="scala" data-trim>
val vacuum = new Vacuum()
val goomba = new Goomba()
vacuum.collect(goomba)
          </code></pre>

        </section>

        <section data-transition="slide-in zoom-out">
          <h2>What happens when the Goomba escapes the suction?</h2>
          <pre class="fragment" ><code class="scala" data-trim>

val vacuum = new Vacuum()

vacuum.collect(null)

          </code></pre>
        </section>

        <section data-transition="zoom-in" data-background="images/funny-squirrel.jpg" data-background-size="contain">
        </section>

        <section data-transition="slide">
          <h2>Solution</h2>
          <p class="fragment">Check For Nulls</p>
          <pre class="fragment"><code class="scala" data-trim >

class Vacuum {
  def collect(s:Goomba) = if (s == null) null else stomp(s)
}

          </code></pre>
          <p class="fragment">But then the calling class runs the risk of NullPointer exceptions.</p>
        </section>

        <section data-transition="zoom-in">
          <p>There must be a better way</p>
          <img class="stretch" data-src="images/better_way.jpg"/>
        </section>

        <section data-transition="slide-in zoom-out">
          <h2>Solution</h2>
          <p class="fragment">Put the Goomba in a Cage</p>
          <pre class="fragment" ><code class="scala" data-trim>
sealed trait Cage[T]
case class FullCage[T](value: T) extends Cage[T]
case class EmptyCage[T]() extends Cage[T]
object Cage {
  def apply[T](x: T):Cage[T] =
            if (x == null) EmptyCage[T]() else FullCage(x)
}
</code></pre>
<pre class="fragment" ><code class="scala" data-trim>
class Vacuum {
  def collect(c:Cage[Goomba]):Cage[Coin] = c match {
    case EmptyCage() => EmptyCage[Coin]()
    case FullCage(s) => FullCage(stomp(s))
  }
}
           </code></pre>

          <pre class="fragment" ><code class="scala" data-trim>
val vac = new Vacuum()

vac.collect(Cage(Goomba()))

vac.collect(Cage(null))
          </code></pre>
        </section>

        <section data-transition="zoom-in" data-background="images/no_boom_boom.jpg" >
        </section>

        <section data-transition="slide">
          <h1>Exceptions are Side Effects</h1>
          <p>Don't let them leak</p>
        </section>

        <section data-transition="slide">
          <h2>Why limit ourself to just stomping Goombas in the cage?</h2>
          <pre class="fragment" ><code class="scala" data-trim>
class Vacuum {

  def collect[A,B](c:Cage[A], f:A => B):Cage[B] = c match {

    case EmptyCage() => EmptyCage[B]()

    case FullCage(s) => FullCage(f(s))

  }
}
        </code></pre>
        </section>

        <section data-transition="slide">
          <h1>Can we generalize the Vacuum class?</h1>
          <img class="stretch" data-src="images/cow.jpg" >
        </section>

        <section data-transition="slide">
          <p>Generalization is a broadening of application to encompass a larger domain of objects of the same or different type</p>
        </section>

        <section data-transition="slide">
          <p>What is the Vacuum class in its simplist form?</p>
        </section>

        <section data-transition="slide">
          <p>Turn it into a trait</p>
          <pre class="fragment" ><code class="scala" data-trim>
trait Collector {
  def collect[A,B](c:Cage[A], f:A => B):Cage[B]
}
        </code></pre>
        <pre class="fragment" ><code class="scala" data-trim>
class Vacuum extends Collector {
  def collect[A,B](c:Cage[A], f:A => B):Cage[B] = c match {
    case EmptyCage() => EmptyCage[B]()
    case FullCage(s) => FullCage(f(s))
  }
}

        </code></pre>
        </section>

        <section data-transition="slide">
          <p>Parameterise the object</p>
          <pre class="fragment" ><code class="scala" data-trim>
trait Collector[F[_]] {

  def collect[A,B](c:F[A], f:A => B): F[B]

}
        </code></pre>
        <pre class="fragment" ><code class="scala" data-trim>
object Vacuum extends Collector[Cage] {
  def collect[A,B](c:Cage[A], f:A => B):Cage[B] = c match {
    case EmptyCage() => EmptyCage[B]()
    case FullCage(s) => FullCage(f(s))
  }
}
        </code></pre>
        </section>

        <section data-transition="zoom-in">
          <img class="stretch" data-src="images/get_the_funk_out.jpg"/>
        </section>

        <section data-transition="slide">
          <h1>The Functor</h1>
          <blockquote>A functor is basically for things that can be mapped over.</blockquote>
        </section>

        <section data-transition="slide">
          <h1>The functor definition in Scalaz</h1>
        </code></pre>
        <pre class="fragment" ><code class="scala" data-trim>
package scalaz

trait Functor[F[_]] extends InvariantFunctor[F] { self =>
  ...
  /** Lift `f` into `F` and apply to `F[A]`. */
   def map[A, B](fa: F[A])(f: A => B): F[B]
  ...
}
        </code></pre>
        </section>

        <section data-transition="slide">
          <h1>How do you use it?</h1>
        <pre class="fragment" ><code class="scala" data-trim>

object CageFunctor extends Functor[Cage] {

  def map[A,B](c:Cage[A])(f:A => B):Cage[B] = c match {
    case EmptyCage => EmptyCage
    case FullCage(s) => FullCage(f(s))
  }

}
        </code></pre>
      <pre class="fragment" ><code class="scala" data-trim>

CageFunctor.map(Cage(Gummba()))(stomp)
      </code></pre>
      </section>

      <section data-transition="slide">
        <h1>Is there a better way?</h1>
      </section>


      <section data-transition="zoom-in" data-background-size="contain" data-background="images/warpzone.jpg" >
      </section>

      <section data-transition="slide">
        <h1>Type classes in 60 seconds</h1>
        <img class="stretch" data-src="images/go_baby.jpg"/>
      </section>

      <section data-transition="slide">
        <h2>Why?</h2>
        <ul>
          <li class="fragment">Extend existing classes</li>
          <li class="fragment">Without inheritance</li>
          <li class="fragment">Without altering original source</li>
          <li class="fragment">Keeps concerns seperate</li>
        </ul>
      </section>

      <section data-transition="slide">
        <h2>How?</h2>
        <h3 class="fragment">3 components</h3>
        <ol>
          <li class="fragment">The type class</li>
          <li class="fragment">Instances for particular types</li>
          <li class="fragment">Interface methods for the api</li>
        </ol>
      </section>

      <section data-transition="slide">
        <h3>The Type Class</h3>
        <p>Provide a generic type of what we want to implement.</p>
        <pre class="fragment" ><code class="scala" data-trim>
trait ProtoBuffWriter[A] {
  def write(value: A): Array[Byte]
}
          </code></pre>
      </section>

      <section data-transition="slide">
        <h3>Type Class Instances</h3>
        <p>Provide implementations for the types we care about.</p>
        <p>Create concrete implementations of the type class and mark them as implicit.</p>
        <pre class="fragment" ><code class="scala" data-trim>
object DefaultProtoBuffWriters {
  implicit val coinWriter = ProtoBuffWriter[Coin] { .... }
  implicit val goombaWriter = ProtoBuffWriter[Goomba] { .... }
  // etc ...
}
          </code></pre>
      </section>

      <section data-transition="slide">
        <h3>Interfaces</h3>
        <p>What is exposed to clients.</p>
        <p>Generic methods that accept instances of the type class as implicit params.</p>
        <h3 class="fragment">Two ways of doing it</h3>
      </section>

      <section data-transition="slide">
        <h3>Interface Objects</h3>
        <p>All methods in a singleton.</p>
        <pre class="fragment" ><code class="scala" data-trim>
object ProtoBuff {
  def toProtoBuff[A](value: A)
  (implicity writer: ProtoBuffWriter[A]): Array[Byte] {
    writer.write(value)
  }
}
          </code></pre>
        <pre class="fragment" ><code class="scala" data-trim>
import DefaultProtoBuffWriters._
val protoBuff: Array[Byte] = ProtoBuff.toProtoBuff(Coin())
        </code></pre>
      </section>

      <section data-transition="slide">
        <h3>Interface Syntax</h3>
        <p>Pimp existing types with interface methods.</p>
        <pre class="fragment" ><code class="scala" data-trim>
object ProtoBuffSyntax {
  implicit class ProtoBuffWriter[A](value: A) {
    def toProtoBuff(implicit writer: ProtoBuffWriter[A])
    : Array[Byte] = {
      writer.write(value)
    }
  }
}
        </code></pre>
        <pre class="fragment" ><code class="scala" data-trim>
import DefaultProtoBuffWriters._
import ProtBuffSyntax._

val protoBuff: Array[Byte] = Coin().toProtoBuff
        </code></pre>
      </section>

      <section data-transition="slide">
        <h1>!!Warning!!</h1>
        <p>Implicits like warp pipes can be dangerous</p>
        <img class="fragment" data-src="images/warp-zone-danger.jpg"/>
      </section>

      <section data-transition="slide">
        <h2>Scalaz Functor Syntax: ToFunctorOps</h2>
        <p>scalaz.syntax.FunctorSyntax.scala</p>
      <pre class="fragment" ><code class="scala" data-trim>
trait ToFunctorOps extends ToFunctorOps0 with ToInvariantFunctorOps
{
implicit def ToFunctorOps[F[_],A](v: F[A])(implicit F0: Functor[F])
= new FunctorOps[F,A](v)
...
}
        </code></pre>
        <p class="fragment">Given a F[A] and a implicit Functor[F] in scope add all the FunctorOps to F[A]</p>
      </section>

      <section data-transition="slide">
        <h2>Scalaz Functor Syntax: FunctorOps</h2>
        <p>scalaz.syntax.FunctorSyntax.scala</p>
      <pre class="fragment" ><code class="scala" data-trim>
final class FunctorOps[F[_],A] private[syntax]
(val self: F[A])(implicit val F: Functor[F]) extends Ops[F[A]] {
...
  final def map[B](f: A => B): F[B] = F.map(self)(f)
...
}
        </code></pre>
        <p class="fragment">Given a F[A] and a implicit Functor[F] in scope delegate the map method to the Functor[F] in scope</p>
      </section>

      <section data-transition="slide">
        <h2>Finally</h2>
        <p>scalaz.syntax package object extends Syntaxes</p>
        <pre class="fragment" ><code class="scala" data-trim>
trait Syntaxes {
  object functor extends ToFunctorOps
}
          </code></pre>
      </section>

      <section data-transition="slide">
        <p>ToFunctorOps: Implicity converts a Functor to Functor Ops</p>
        <p>FunctorOps: Uses the implicit Functor in scope add the map method to the Type</p>

      </section>

      <section data-transition="slide">
        <h2>Cage Functor again</h2>
        <p>scalaz.syntax.FunctorSyntax.scala</p>
      <pre class="fragment" ><code class="scala" data-trim>
import scalaz.Functor
implicit object CageFunctor extends Functor[Cage] {

  def map[A,B](c:Cage[A])(f:A => B):Cage[B] = c match {
    case EmptyCage => EmptyCage
    case FullCage(s) => FullCage(f(s))
  }
}
        </code></pre>
        <pre class="fragment" ><code class="scala" data-trim>
import scalaz.syntax.functor
Cage(Goomba()).map(stomp)

          </code></pre>
      </section>

      <section data-transition="slide">
        <h1>The Functor Laws</h1>
        <p>Mapping preserves identity</p>
        <p>Mapping respects composition</p>
      </section>


      <section data-transition="slide">
        <h2>Does your functor break laws?</h2>
      <pre class="fragment" ><code class="scala" data-trim>
import org.scalacheck.Arbitrary
import org.specs2.scalaz.Spec
import scalaz.Equal
import scalaz.scalacheck.ScalazProperties

class CageFunctorSpec extends Spec {
  implicit val abrCage = Arbitrary[Cage[Int]] {
    for {
      ns <- Arbitrary.arbInt.arbitrary
    } yield Cage(ns)
  }

  implicit val cageEqual = Equal.equal[Cage[Int]]((a, b) => a == b)

  checkAll(ScalazProperties.functor.laws[Cage])
}
      </code></pre>
      <pre class="fragment" ><code class="scala" data-trim>
val scalazVersion = "7.1.3"

libraryDependencies ++= Seq(
  "org.scalaz"    %% "scalaz-core"   % scalazVersion,
  "org.specs2"    %% "specs2-core"   % "2.4"           % "test",
  "org.typelevel" %% "scalaz-specs2" % "0.3.0"         % "test"
)
    </code></pre>
      </section>

      <section data-transition="slide">
        <h2>Remember the three questions?</h2>
        <ul>
        <li class="fragment">Abstraction: Functor is a abstract concept</li>
        <li class="fragment">Generalization: There is a set of objects that can be mapped over</li>
      </ul>
      <p class="fragment">What about the context?</p>
      </section>

      <section data-transition="slide">
        <h1>Context</h1>
        <p>Context is the environment the function is applied in.</p>
        <p>Remember the comment Lift `f` into `F` and apply to `F[A]`</p>

      </section>

      <section data-transition="slide">
        <img data-src="images/function_in_context.png" class="stretch">
      </section>

      <section data-transition="slide">
        <h1>Meet some more Contexts</h1>
      </section>

      <section data-transition="slide">
        <h3>Cage is really scala.Option</h3>
        <pre class="fragment" ><code class="scala" data-trim>
sealed abstract class Option[+A] extends Product with Serializable {
...
final def map[B](f: A => B): Option[B] =
    if (isEmpty) None else Some(f(this.get))
...
}
      </code></pre>
      <p class="fragment">Scalaz provides implicits to convert Option to a Functor trait</p>
      <pre class="fragment" ><code class="scala" data-trim>
import scalaz.std.option._
import scalaz.std.anyVal._

checkAll(ScalazProperties.functor.laws[Option])
    </code></pre>
      <p class="fragment">Option is context for a computation that might fail</p>
      </section>

      <section data-transition="slide">
        <h3>List are also functors</h3>
        <pre class="fragment" ><code class="scala" data-trim>
sealed abstract class List[+A] { ....
final def map[B](f: (A) ⇒ B): List[B]
  ...
}
        </code></pre>
<p class="fragment">Scalaz provides implicits to convert List to a Functor trait</p>
<pre class="fragment" ><code class="scala" data-trim>
import scalaz.std.list._
import scalaz.std.anyVal._
import org.specs2.scalaz.Spec
import scalaz.scalacheck.ScalazProperties

class ListFunctorSpec extends Spec {
  checkAll(ScalazProperties.functor.laws[List])
}
</code></pre>
        <p class="fragment">If 6 is deterministic and is thought as having one value.<br>
          The List context such as List(1,10,3,4) can be thought of as having multipule values at once.
        </p>
        <p class="fragment">Or no values if empty</p>
      </section>

      <section data-transition="slide">
        <h1>So why is this so handy?</h1>
      </section>

      <section data-transition="slide">
        <h2>Ordinary functions are simpler to:</h2>
          <ul>
            <li>read</li>
            <li>write</li>
            <li>use</li>
            <li>reason about</li>
          </ul>
      </section>

      <section data-transition="slide">
        <h2>Functions in a context have useful properties</h2>
        <p class="fragment">Functors let us write ordinary functions</p>
        <p class="fragment">then promote those functions into what every context might need that code</p>
        <p class="fragment">As new contexts arise we just define new functors to promote our ordinary code to work in those contexts.</p>
      </section>

      <section data-transition="slide">
        <pre class="stretch"><code class="scala" data-trim>
///Ordinary function
def stomp(g:Goomba) = g.stomp()

///The context
sealed trait Cage[T]
case class FullCage[T](value: T) extends Cage[T]
case class EmptyCage[T]() extends Cage[T]
object Cage {
  def apply[T](x: T):Cage[T] =
            if (x == null) EmptyCage[T]() else FullCage(x)
}

///Promote into context
import scalaz.Functor
implicit object CageFunctor extends Functor[Cage] {
  def map[A,B](c:Cage[A])(f:A => B):Cage[B] = c match {
    case EmptyCage() => EmptyCage[B]()
    case FullCage(s) => FullCage(f(s))
  }
}

///use
import scalaz.syntax.functor
Cage(Goomba()).map(stomp)

</code></pre>
      </section>

  <section data-transition="zoom-in" data-background-size="contain" data-background="images/world-1-1-flag.jpg" >
  </section>


  <section data-transition="slide">
    <h1>World 1-2</h1>
    <p>Applicative</p>
  </section>

  <section data-transition="slide">
    <h2>Piranha Plant</h2>
    <p>TODO:Add image</p>
    <pre class="fragment" ><code class="scala" data-trim>
case class Coin()
case class Goomba()
case class Fireball()
case class PiranhaPlant()
def shoot(plant:PiranhaPlant, fireball:Fireball): Coin = Coin()
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>The plant is generated from a unreliable method</h3>
    <p>Wrap the plant in a Option and map over it?</p>
<pre class="fragment" ><code class="scala" data-trim>
Option(PiranhaPlant()).map(shoot _)
    </code></pre>
    <pre class="fragment" ><code class="scala" data-trim>
      <console>:31: error: type mismatch;
found   : (PiranhaPlant, Fireball) => Coin
required: PiranhaPlant => ?
            Option(PiranhaPlant()).map(shoot _)
        </code></pre>
  </section>

  <section data-transition="slide" data-background-size="contain" data-background="images/curry.jpg" >
    <h2 ><font color="#f08">Curring</font></h2>
  </section>

  <section data-transition="slide">
    <h2>Curring is partial application</h2>
    <p>Translating the evaluation of a function that takes multiple arguments
       into evaluating a sequence of functions, each with a single argument
    <pre class="fragment" ><code class="scala" data-trim>
(shoot _).curried
//res41: PiranhaPlant => (Fireball => Coin) = <function1>
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Map the curried shoot function</h3>
    <pre class="fragment" ><code class="scala" data-trim>
Option(PiranhaPlant()) map {shoot _}.curried
//Option[Fireball => Coin] = ...
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>What if the fireball parameter generation is in a context?</h3>
    <p class="fragment">Functor only support mapping functions over functor</p>
    <pre class="fragment" ><code class="scala" data-trim>
def map[A, B](fa: F[A])(f: A => B): F[B]
    </code></pre>
    <p class="fragment">We need to map function in a functor over a value in a functor</p>
    <p>
  </section>

  <section data-transition="slide">
    <h3>Apply</h3>
<pre class="fragment" ><code class="scala" data-trim>
package scalaz
trait Apply[F[_]] extends Functor[F] { self =>
  ////
  def ap[A,B](fa: => F[A])(f: => F[A => B]): F[B]
  ...
}
</code></pre>

<pre class="fragment" ><code class="scala" data-trim>
package scalaz
package syntax

final class ApplyOps[F[_],A] private[syntax](val self: F[A])
(implicit val F: Apply[F]) extends Ops[F[A]] {
  final def <*>[B](f: F[A => B]): F[B] = F.ap(self)(f)
...
}

trait ToApplyOps extends ToApplyOps0 with ToFunctorOps {
  implicit def ToApplyOps[F[_],A](v: F[A])(implicit F0: Apply[F]) =
    new ApplyOps[F,A](v)
...
}
</code></pre>

  </section>

  <section data-transition="slide">
    <h3>What would our vacuum look like?</h3>
    <pre class="fragment" ><code class="scala" data-trim>
implicit object CageApply extends Apply[Cage] with Functor[Cage] {
  override def ap[A, B](fa: => Cage[A])(fab: => Cage[(A) => B]): Cage[B] =  fab match {
    case FullCage(f) => fa match {
      case FullCage(x) => FullCage(f(x))
      case EmptyCage()    => EmptyCage[B]()
    }
    case EmptyCage()    => EmptyCage[B]()
  }

  override def map[A, B](fa: Cage[A])(f: (A) => B): Cage[B] = CageFunctor.map(fa)(f)
}
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>How would you use it?</h3>
    <pre class="fragment" ><code class="scala" data-trim>
val partialShoot = Cage(PiranhaPlant()) <*> Cage((shoot _).curried)
val optCoin = Cage(Fireball()) <*> partialShoot
//optCoin: Cage[Coin] = FullCage(Coin())
    </code></pre>

  </section>

  <section data-transition="slide">
    <h3>The laws</h3>
    <pre class="stretch" ><code class="scala" data-trim>
import org.scalacheck.Arbitrary
import org.specs2.scalaz.Spec
import scalaz.Equal
import scalaz.scalacheck.ScalazProperties

class CageApplySpec extends Spec {
  
  implicit val abrCage = Arbitrary[Cage[Int]] {
    for {
      ns <- Arbitrary.arbInt.arbitrary
    } yield Cage(ns)
  }

  implicit val arbCageIntToInt = Arbitrary[Cage[Int => Int]] {
    for{
      multi <- Arbitrary.arbInt.arbitrary
    } yield Cage((x:Int) => x * multi)
  }

  implicit val cageEqual = Equal.equal[Cage[Int]]((a, b) => a == b)

  checkAll(ScalazProperties.apply.laws[Cage])
}
    </code></pre>

  </section>

  <section data-transition="slide">
    <h3>Option Apply: OptionInstances</h3>
    <pre class="fragment" ><code class="scala" data-trim>
package scalaz
package std

override def ap[A, B](fa: => Option[A])(f: => Option[A => B]) = f match {
  case Some(f) => fa match {
    case Some(x) => Some(f(x))
    case None    => None
  }
  case None    => None
}
    </code></pre>
  </section>

  <section data-transition="slide">
    <h3>Shoot that Piranha Plant</h3>
    <pre class="fragment" ><code class="scala" data-trim>
import scalaz.std.option._

val partialShoot = Option(PiranhaPlant()) <*> Option((shoot _).curried)
val optCoin = Option(Fireball()) <*> partialShoot
//optCoin: Option[Coin] = Some(Coin())
    </code></pre>
    <p class="That's a bit hard to follow">
  </section>

  <section data-transition="slide">
    <h3>Some nicer syntax</h3>
    <pre class="fragment" ><code class="scala" data-trim>
import scalaz.std.option._
import scalaz.syntax.apply._

^(Option(PiranhaPlant()), Option(Fireball()))(shoot)
//res69: Option[Coin] = Some(Coin())

import scalaz.Apply
Apply[Option]
.lift2(shoot)(Option(PiranhaPlant()), Option(Fireball()))
//res70: Option[Coin] = Some(Coin())

(Option(PiranhaPlant()) |@| Option(Fireball()))(shoot)
//res71: Option[Coin] = Some(Coin())
    </code></pre>
  </section>


  <section data-transition="slide">
    <h3></h3>
  </section>

</div>
